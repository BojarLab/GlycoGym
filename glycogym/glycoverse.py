import copy
import itertools
from typing import Generator

from glycowork.motif.graph import get_possible_topologies, glycan_to_nxGraph
import networkx as nx
from tqdm import tqdm


def get_all_iupacs(graph: nx.DiGraph) -> list[str]:
    """
    Generate all possible IUPAC-condensed strings for a glycan graph by performing a depth-first search (DFS) traversal.

    Args:
        graph (nx.DiGraph): A directed graph representing the glycan structure.
    
    Returns:
        list[str]: A list of all possible IUPAC-condensed glycan strings.
    """
    def dfs_to_strings(G: nx.DiGraph, idx: int) -> list[str]:  # all possible IUPAC-condensed glycan strings
        # Convert the DFS tree of a glycan graph to IUPAC-condensed format recursively
        output = graph.nodes[idx]["string_labels"]
        # put braces around the string describing linkages
        if (output[0] in "?abn" or output[0].isdigit()) and (output[-1] == "?" or output[-1].isdigit()):
            output = "(" + output + ")"
        # sort kids from shallow to deep to have deepest as main branch in the end
        children = list(G.neighbors(idx))
        if len(children) == 0:
            return [output]
        # iterate over all possible alternations of "children"
        outputs = []
        for child_order in itertools.permutations(children, r=len(children)):
            child_outputs = [dfs_to_strings(G, child) for child in child_order]
            outputs += [cs[-1] + "".join(f"[{c}]" for c in cs[:-1]) + output for cs in itertools.product(*child_outputs)]
        return outputs

    # get the root node index, assuming the root node has the highest index
    root_idx = max(list(graph.nodes.keys()))

    # get the DFS tree of the graph
    dfs = nx.dfs_tree(graph, root_idx)

    # convert the DFS tree to IUPAC-condensed format
    return dfs_to_strings(dfs, root_idx)


def generate_minus_one_subgraphs(graph: nx.DiGraph) -> Generator[nx.DiGraph, None, None]:
    """
    Generate all subgraphs by removing one leaf node from the glycan graph.

    Args:
        graph (nx.DiGraph): A directed graph representing the glycan structure.

    Yields:
        nx.DiGraph: A subgraph with one leaf node removed.
    """
    if len(graph.nodes()) == 1:
        yield graph
    else:
        leafs = [x for x in graph.nodes() if graph.degree(x) == 1 and x != max(graph.nodes)]
        for x in leafs: 
            G = copy.deepcopy(graph)
            parent = list(G.predecessors(x))[0]
            G.remove_node(x)
            G.remove_node(parent)
            yield G


def explore_subgraph_topology(graph: nx.DiGraph) -> set[str]:
    """
    Recursively explode a glycan graph into all possible subgraphs and collect their IUPAC-condensed strings.
    Step 1: Base case - if the graph has one or zero nodes, return an empty set.
    Step 2: For each subgraph generated by removing one leaf node:
        a) Check if any of the IUPAC strings of the subgraph are already known.
        b) If not known, recursively explode the subgraph and add its IUPAC strings to the set.
    
    Args:
        graph (nx.DiGraph): A directed graph representing the glycan structure.
    
    Returns:
        set[str]: A set of unique IUPAC-condensed glycan strings obtained from the exploded subgraphs.
    """
    unique_iupacs = set()
    if len(graph.nodes) <= 1:
        return set()
    for subgraph in generate_minus_one_subgraphs(graph):  # Step 2
        known_subgraph = False
        for i in get_all_iupacs(subgraph):  # Step 2
            if i in unique_iupacs:  # Step 2a
                known_subgraph = True
                break
            unique_iupacs.add(i)  # Step 2b
        if not known_subgraph:
            unique_iupacs = unique_iupacs.union(explore_subgraph_topology(subgraph))
    return unique_iupacs


def get_possible_topologies_ext(graph: nx.DiGraph, exhaustive: bool = True) -> list[nx.DiGraph]:
    """
    Generate all possible topologies for a glycan graph. If the graph is already connected,
    return it as the only topology. Otherwise, use the get_possible_topologies function
    to generate all possible topologies.

    Args:
        graph (nx.DiGraph): A directed graph representing the glycan structure.
        exhaustive (bool): Whether to generate all possible topologies exhaustively.

    Returns:
        list[nx.DiGraph]: A list of glycan graphs representing all possible topologies
    """
    if len(list(nx.weakly_connected_components(graph))) == 1:
        return [graph]
    return get_possible_topologies(graph, exhaustive=exhaustive, return_graphs=True)  # type: ignore


def explore_glycoverse(iupacs: list[str]) -> set[str]:
    """
    "Explode" a list of glycan IUPAC-condensed strings into all unique substructures.

    Step 0: Read glycans to graph, one by one
    Step 1: Resolve floating elements
    Step 2: Extract all subgraphs
        a) Check if new subgraph is part of seen, if yes, abort and go to next subgraph
        b) For each new subgraph, generate all IUPAC strings and insert them into the datastructure
    post processing: expand every string by binding-explosion: (a1-2) -> [(a1-2), a1-2, a2]
    """
    iupacs = list(sorted(iupacs, key=lambda x: (x.count("["), x.count("("))))
    unique_iupacs = set()

    for iupac in tqdm(iupacs):
        try:
            # if i % checkpoint_frequency == (checkpoint_frequency - 1):
            #     with open(f"unique_iupacs_{i + 1}.pkl", "wb") as out:
            #         pickle.dump(unique_iupacs, out)
            #     if os.path.exists(f"unique_iupacs_{i + 1 - checkpoint_frequency}.pkl"):
            #         os.remove(f"unique_iupacs_{i + 1 - checkpoint_frequency}.pkl")
            if iupac in unique_iupacs:
                continue
            unique_iupacs.add(iupac)
            graph = glycan_to_nxGraph(iupac)  # Step 0
            for topo in get_possible_topologies_ext(graph, exhaustive=True):  # Step 1
                try:
                    unique_iupacs = unique_iupacs.union(explore_subgraph_topology(topo))
                except Exception as e:
                    print(f"Processing failed for {iupac} with {e}. Please report this to the GlycoGym Issue tracker on GitHub.")  # failed.append((iupac, 2, e))
        except Exception as e:
            print(f"Processing failed for {iupac} with {e}. Please report this to the GlycoGym Issue tracker on GitHub.")  # failed.append((iupac, 1, e))
    return unique_iupacs
